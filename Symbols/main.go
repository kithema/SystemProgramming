package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	parse("24.txt")
}

func parse(src string) {
	// Открываем файл "24.txt" для чтения и обрабатываем возможные ошибки при открытии.
	file, err := os.Open(src)
	if err != nil {
		fmt.Println(err)
		return
	}
	// Используем defer для автоматического закрытия файла после завершения функции, чтобы избежать утечек ресурсов.
	defer file.Close()

	// Создаем буферизованный сканер для чтения содержимого файла построчно.
	scanner := bufio.NewScanner(file)
	// Пытаемся прочитать первую строку файла.
	if !scanner.Scan() {
		fmt.Println("No content in file") // Выводим сообщение, если файл пустой.
		return
	}
	// Получаем текст первой строки файла и сохраняем в переменную f.
	f := scanner.Text()

	// Инициализируем переменные:
	// k - текущая длина последовательности (счетчик для текущей цепочки X-Y-Z).
	// m - максимальная длина последовательности, найденная на данный момент.
	k, m := 0, 0

	// Проходим по каждому символу в строке f.
	for i := 0; i < len(f); i++ {
		ch := f[i] // Текущий символ.

		// Вычисляем остаток от деления текущей длины k на 3, чтобы определить ожидаемый символ в цикле X-Y-Z.
		mod := k % 3

		// Проверяем, соответствует ли текущий символ ожидаемому в последовательности:
		// - Если mod == 0, ожидаем 'X'
		// - Если mod == 1, ожидаем 'Y'
		// - Если mod == 2, ожидаем 'Z'
		if (ch == 'X' && mod == 0) || (ch == 'Y' && mod == 1) || (ch == 'Z' && mod == 2) {
			k++ // Увеличиваем текущую длину последовательности.
			if k > m {
				m = k // Обновляем максимальную длину, если текущая больше.
			}
		// Если символ 'X', но не в начале цикла, начинаем новую последовательность с длины 1.
		} else if ch == 'X' {
			k = 1
		// Для любых других символов сбрасываем текущую последовательность.
		} else {
			k = 0
		}
	}

	// Выводим максимальную найденную длину последовательности.
	fmt.Println(m)
}
