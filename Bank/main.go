package main

import (
	"fmt"
	"math/rand"
	"sync"
)

// Account представляет банковский счет
// balance - текущий баланс счета
// goal - целевая сумма, при достижении которой происходит снятие
// mu - мьютекс для обеспечения потокобезопасности операций со счетом
type Account struct {
	balance int
	goal    int
	mu      sync.Mutex
}

// NewAccount создает новый экземпляр счета
// initialBalance - начальный баланс счета
// goal - целевая сумма для снятия
// Возвращает указатель на созданный Account
func NewAccount(initialBalance, goal int) *Account {
	return &Account{
		balance: initialBalance,
		goal:    goal,
	}
}

// Deposit пополняет счет на указанную сумму
// amount - сумма для пополнения
// Возвращает новый баланс после пополнения
// Метод потокобезопасен благодаря использованию мьютекса
func (a *Account) Deposit(amount int) int {
	a.mu.Lock()         // Блокируем мьютекс для исключительного доступа
	defer a.mu.Unlock() // Гарантируем разблокировку мьютекса при выходе из функции
	
	a.balance += amount // Увеличиваем баланс на сумму пополнения
	return a.balance    // Возвращаем обновленный баланс
}

// Withdraw пытается снять указанную сумму со счета
// amount - сумма для снятия
// Возвращает true если снятие прошло успешно, false если недостаточно средств
// Метод потокобезопасен благодаря использованию мьютекса
func (a *Account) Withdraw(amount int) bool {
	a.mu.Lock()         // Блокируем мьютекс для исключительного доступа
	defer a.mu.Unlock() // Гарантируем разблокировку мьютекса при выходе из функции
	
	// Проверяем, достаточно ли средств на счете для снятия
	if a.balance >= amount {
		a.balance -= amount // Уменьшаем баланс на сумму снятия
		return true         // Возвращаем успех операции
	}
	return false // Возвращаем неудачу - недостаточно средств
}

// GetBalance возвращает текущий баланс счета
// Возвращает текущее значение баланса
// Метод потокобезопасен благодаря использованию мьютекса
func (a *Account) GetBalance() int {
	a.mu.Lock()         // Блокируем мьютекс для исключительного доступа
	defer a.mu.Unlock() // Гарантируем разблокировку мьютекса при выходе из функции
	return a.balance    // Возвращаем текущий баланс
}

func main() {
	
	// Создаем новый счет с начальным балансом 10 и целевой суммой 1000
	account := NewAccount(10, 1000)
	
	// Создаем WaitGroup для ожидания завершения горутины
	var wg sync.WaitGroup

	// Увеличиваем счетчик WaitGroup на 1, так как мы запускаем одну горутину
	wg.Add(1)
	
	// Запускаем горутину для пополнения счета
	go func() {
		// Уменьшаем счетчик WaitGroup при завершении горутины
		defer wg.Done()
		
		// Бесконечный цикл для многократного пополнения счета
		for {
			// Генерируем случайную сумму от 1 до 100 для пополнения
			amount := rand.Intn(100) + 1
			
			// Пополняем счет и получаем новый баланс
			newBalance := account.Deposit(amount)
			
			// Выводим информацию о пополнении и текущем балансе
			fmt.Printf("Deposited %d, current balance: %d\n", amount, newBalance)
			
			// Проверяем, достигли ли мы целевой суммы
			if newBalance >= account.goal {
				// Пытаемся снять целевую сумму
				if account.Withdraw(account.goal) {
					// Если снятие успешно, выводим информацию и выходим из цикла
					fmt.Printf("Withdrawn %d, balance after: %d\n", account.goal, account.GetBalance())
					break // Выходим из бесконечного цикла
				}
			}
		}
	}() // Конец анонимной функции-горутины

	// Ожидаем завершения всех горутин, добавленных в WaitGroup
	// В данном случае ждем завершения только одной горутины
	wg.Wait()

	// Выводим окончательный баланс после всех операций
	fmt.Println("Final balance:", account.GetBalance())
}